Subject: [PATCH] feat(drive): support alidrive_tv
---
Index: src/driver/alicloud_tv.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/driver/alicloud_tv.ts b/src/driver/alicloud_tv.ts
--- a/src/driver/alicloud_tv.ts	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/src/driver/alicloud_tv.ts	(date 1751453387251)
@@ -1,14 +1,31 @@
-import express from 'express';
-import * as crypto from 'crypto';
-import * as uuid from 'uuid';
-import axios from 'axios';
-import qrcode from 'qrcode-terminal';
-import bodyParser from 'body-parser';
-import { Request, Response } from 'express';
+import {Context} from "hono";
+import * as refresh from "../shares/refresh";
+import * as configs from "../shares/configs";
+
+// 用于替代 Node.js 的 crypto.randomUUID
+function generateUUID(): string {
+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
+        const r = Math.random() * 16 | 0;
+        const v = c === 'x' ? r : (r & 0x3 | 0x8);
+        return v.toString(16);
+    });
+}
 
-const app = express();
-app.use(bodyParser.json());
+// 定义API响应的接口
+interface ApiResponse {
+    code?: number;
+    data?: Record<string, any>;
+    t?: string;
+    message?: string;
+}
 
+// 定义Token数据接口
+interface TokenData {
+    ciphertext: string;
+    iv: string;
+}
+
+// 阿里云盘TV版token获取类
 class AliyunPanTvToken {
     private timestamp: string;
     private uniqueId: string;
@@ -18,48 +35,57 @@
     private akv: string;
     private apv: string;
     private headersBase: Record<string, string>;
+    private initialized: boolean = false;
 
     constructor() {
-        try {
-            this.timestamp = '';
-            this.uniqueId = uuid.v4().replace(/-/g, '');
-            this.wifimac = Math.floor(100000000000 + Math.random() * 900000000000).toString();
-            this.model = "SM-S908E";
-            this.brand = "samsung";
-            this.akv = "2.6.1143";
-            this.apv = "1.4.0.2";
+        // 构造函数中只设置默认值，不执行异步操作
+        // this.timestamp = Date.now().toString(); // 设置默认时间戳
+        this.timestamp = ''
+        this.uniqueId = generateUUID().replace(/-/g, '');
+        // this.wifimac = Math.floor(100000000000 + Math.random() * 900000000000).toString();
+        this.wifimac = "020000000000";
+        this.model = "SM-S908E";
+        this.brand = "samsung";
+        this.akv = "2.6.1143";
+        this.apv = "1.4.0.2";
 
-            this.headersBase = {
-                "User-Agent": "Mozilla/5.0 (Linux; U; Android 15; zh-cn; SM-S908E Build/UKQ1.231108.001) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1",
-                "Host": "api.extscreen.com",
-                "Content-Type": "application/json;",
-            };
-
-            this.initTimestamp();
-        } catch (error) {
-            console.error("初始化错误:", error);
-            process.exit(1);
-        }
+        this.headersBase = {
+            "User-Agent": "Mozilla/5.0 (Linux; U; Android 15; zh-cn; SM-S908E Build/UKQ1.231108.001) AppleWebKit/533.1 (KHTML, like Gecko) Mobile Safari/533.1",
+            "Host": "api.extscreen.com",
+            "Content-Type": "application/json;",
+        };
     }
+
+    // 懒加载初始化方法，在首次API调用时执行
+    private async ensureInitialized(): Promise<void> {
+        if (this.initialized) return;
 
-    private async initTimestamp() {
         try {
-            const response = await axios.get("http://api.extscreen.com/timestamp", { timeout: 10000 });
-            this.timestamp = response.data.data.timestamp.toString();
+            const response = await fetch("http://api.extscreen.com/timestamp");
+            const data = await response.json() as { data?: { timestamp?: number } };
+            if (data?.data?.timestamp) {
+                this.timestamp = data.data.timestamp.toString();
+            }
         } catch (error) {
             console.error("获取时间戳错误:", error);
-            this.timestamp = Date.now().toString();
+            // 保持默认时间戳
+        } finally {
+            this.initialized = true;
         }
     }
 
+    // 精确匹配Python版本的h函数
     private h(charArray: string[], modifier: string): string {
+        // 获取唯一字符，与Python的list(dict.fromkeys(char_array))等效
         const uniqueChars = Array.from(new Set(charArray));
-        const modifierStr = modifier.toString();
+        const modifierStr = String(modifier);
+        // 与Python的substring逻辑完全一致
         const numericModifierStr = modifierStr.length > 7 ? modifierStr.substring(7) : '0';
         let numericModifier: number;
 
         try {
-            numericModifier = parseInt(numericModifierStr, 10) || 0;
+            numericModifier = parseInt(numericModifierStr, 10);
+            if (isNaN(numericModifier)) numericModifier = 0;
         } catch {
             numericModifier = 0;
         }
@@ -78,7 +104,7 @@
             try {
                 transformedString += String.fromCharCode(newCharCode);
             } catch {
-                // 跳过无效字符
+                // 跳过无效字符，与Python行为一致
             }
         }
 
@@ -99,86 +125,153 @@
         };
     }
 
-    private generateKey(): string {
+    // 与Python版本完全匹配的MD5实现
+    private async md5(str: string): Promise<string> {
+        const encoder = new TextEncoder();
+        const data = encoder.encode(str);
+        const hashBuffer = await crypto.subtle.digest('MD5', data);
+        const hashArray = Array.from(new Uint8Array(hashBuffer));
+        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
+    }
+
+    // 与Python版本完全匹配的SHA-256实现
+    private async sha256(str: string): Promise<string> {
+        const encoder = new TextEncoder();
+        const data = encoder.encode(str);
+        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
+        const hashArray = Array.from(new Uint8Array(hashBuffer));
+        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
+    }
+
+    // 精确匹配Python版本的generateKey实现
+    private async generateKey(): Promise<string> {
         const params = this.getParams();
         const sortedKeys = Object.keys(params).sort();
-        const concatenatedParams = sortedKeys
-            .filter(key => key !== "t")
-            .map(key => params[key].toString())
-            .join("");
+        // 使用与Python完全相同的连接方式
+        let concatenatedParams = "";
+        for (const key of sortedKeys) {
+            if (key !== 't') {
+                concatenatedParams += String(params[key]);
+            }
+        }
 
-        const keyArray = concatenatedParams.split("");
+        const keyArray = concatenatedParams.split('');
         const hashedKey = this.h(keyArray, this.timestamp);
-        return crypto.createHash('md5').update(hashedKey).digest('hex');
+        return await this.md5(hashedKey);
     }
 
-    private generateKeyWithT(t: string): string {
+    private async generateKeyWithT(t: string): Promise<string> {
         const params = this.getParams();
         params.t = t;
         const sortedKeys = Object.keys(params).sort();
-        const concatenatedParams = sortedKeys
-            .filter(key => key !== "t")
-            .map(key => params[key].toString())
-            .join("");
+        // 使用与Python完全相同的连接方式
+        let concatenatedParams = "";
+        for (const key of sortedKeys) {
+            if (key !== 't') {
+                concatenatedParams += String(params[key]);
+            }
+        }
 
-        const keyArray = concatenatedParams.split("");
+        const keyArray = concatenatedParams.split('');
         const hashedKey = this.h(keyArray, t);
-        return crypto.createHash('md5').update(hashedKey).digest('hex');
+        return await this.md5(hashedKey);
     }
 
+    // 与Python版本完全匹配的随机IV生成
     private randomIvStr(length: number = 16): string {
         const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
-        return Array.from({ length }, () =>
-            chars.charAt(Math.floor(Math.random() * chars.length))
-        ).join('');
+        let result = '';
+        for (let i = 0; i < length; i++) {
+            result += chars.charAt(Math.floor(Math.random() * chars.length));
+        }
+        return result;
     }
 
-    private encrypt(plainObj: any): { iv: string, ciphertext: string } {
-        const key = this.generateKey();
+    // 与Python版本完全匹配的加密实现
+    private async encrypt(plainObj: any): Promise<{ iv: string, ciphertext: string }> {
+        // 1. 生成密钥 - 与Python完全一致
+        const key = await this.generateKey();
+
+        // 2. 生成随机IV - 与Python完全一致
         const ivStr = this.randomIvStr(16);
-        const keyBytes = Buffer.from(key, 'utf-8');
-        const ivBytes = Buffer.from(ivStr, 'utf-8');
-        const plaintext = Buffer.from(JSON.stringify(plainObj), 'utf-8');
+
+        // 3. 准备加密数据 - 确保使用与Python相同的JSON序列化格式
+        // Python: json.dumps(plain_obj, separators=(',', ':'))
+        const plaintext = JSON.stringify(plainObj).replace(/\s/g, '');
 
-        // PKCS7 填充
-        const blockSize = 16;
-        const pad = blockSize - (plaintext.length % blockSize);
-        const paddedPlaintext = Buffer.concat([
-            plaintext,
-            Buffer.alloc(pad, pad)
-        ]);
+        // 4. 创建UTF-8编码的数据
+        const encoder = new TextEncoder();
+        const keyBytes = encoder.encode(key);
+        const ivBytes = encoder.encode(ivStr);
+        const plaintextBytes = encoder.encode(plaintext);
 
-        const cipher = crypto.createCipheriv('aes-256-cbc', keyBytes, ivBytes);
-        const ciphertext = Buffer.concat([
-            cipher.update(paddedPlaintext),
-            cipher.final()
-        ]);
+        // 6. 使用Web Crypto API进行AES-CBC加密
+        const cryptoKey = await crypto.subtle.importKey(
+            'raw',
+            keyBytes,
+            { name: 'AES-CBC', length: 128 },
+            false,
+            ['encrypt']
+        );
 
+        const encryptedBuffer = await crypto.subtle.encrypt(
+            { name: 'AES-CBC', iv: ivBytes },
+            cryptoKey,
+            plaintextBytes
+        );
+
+        // 7. 转换为Base64编码 - 与Python的base64.b64encode(ciphertext).decode("utf-8")一致
+        const encryptedArray = new Uint8Array(encryptedBuffer);
+        let binary = '';
+        for (let i = 0; i < encryptedArray.length; i++) {
+            binary += String.fromCharCode(encryptedArray[i]);
+        }
+        const base64Ciphertext = btoa(binary);
+
+        // 8. 返回与Python一致的结构
         return {
             iv: ivStr,
-            ciphertext: ciphertext.toString('base64')
+            ciphertext: base64Ciphertext
         };
     }
 
-    private decrypt(ciphertext: string, iv: string, t?: string): string {
+    // 与Python版本完全匹配的解密实现
+    private async decrypt(ciphertext: string, iv: string, t?: string): Promise<string> {
         try {
-            const key = t ? this.generateKeyWithT(t) : this.generateKey();
-            const keyBytes = Buffer.from(key, 'utf-8');
-            const ivBytes = Buffer.from(iv, 'hex');
+            // 1. 生成密钥 - 与Python一致
+            const key = t ? await this.generateKeyWithT(t) : await this.generateKey();
 
-            const cipher = crypto.createDecipheriv('aes-256-cbc', keyBytes, ivBytes);
-            const encryptedBuffer = Buffer.from(ciphertext, 'base64');
+            // 2. 解码Base64密文 - 与Python一致
+            const binaryString = atob(ciphertext);
+            const bytes = new Uint8Array(binaryString.length);
+            for (let i = 0; i < binaryString.length; i++) {
+                bytes[i] = binaryString.charCodeAt(i);
+            }
 
-            const decrypted = Buffer.concat([
-                cipher.update(encryptedBuffer),
-                cipher.final()
-            ]);
+            // 3. 解码十六进制IV - 与Python中的bytes.fromhex(iv)一致
+            const ivBytes = new Uint8Array(iv.length / 2);
+            for (let i = 0; i < iv.length; i += 2) {
+                ivBytes[i / 2] = parseInt(iv.substring(i, i + 2), 16);
+            }
 
-            // PKCS7 去除填充
-            const padValue = decrypted[decrypted.length - 1];
-            const unpadded = decrypted.slice(0, decrypted.length - padValue);
+            // 4. 导入密钥
+            const cryptoKey = await crypto.subtle.importKey(
+                'raw',
+                new TextEncoder().encode(key),
+                { name: 'AES-CBC', length: 256 },
+                false,
+                ['decrypt']
+            );
 
-            return unpadded.toString('utf-8');
+            // 5. 解密
+            const decryptedBuffer = await crypto.subtle.decrypt(
+                { name: 'AES-CBC', iv: ivBytes },
+                cryptoKey,
+                bytes
+            );
+
+            // 7. 转换为字符串
+            return new TextDecoder().decode(decryptedBuffer);
         } catch (error) {
             console.error("解密失败:", error);
             throw error;
@@ -201,17 +294,21 @@
         };
     }
 
-    private computeSign(method: string, apiPath: string): string {
+    // 与Python版本完全匹配的计算sign实现
+    private async computeSign(method: string, apiPath: string): Promise<string> {
         const apiPathAdjusted = "/api" + apiPath;
-        const key = this.generateKey();
+        const key = await this.generateKey();
         const content = `${method}-${apiPathAdjusted}-${this.timestamp}-${this.uniqueId}-${key}`;
-        return crypto.createHash('sha256').update(content, 'utf-8').digest('hex');
+        return await this.sha256(content);
     }
 
     public async getToken(refreshToken: string): Promise<string> {
+        // 确保已初始化
+        await this.ensureInitialized();
+
         try {
             const bodyObj = { refresh_token: refreshToken };
-            const encrypted = this.encrypt(bodyObj);
+            const encrypted = await this.encrypt(bodyObj);
             const reqBody = {
                 iv: encrypted.iv,
                 ciphertext: encrypted.ciphertext
@@ -219,25 +316,45 @@
 
             console.log("[*] (Sign) Request Body:", JSON.stringify(reqBody));
 
-            const sign = this.computeSign("POST", "/v4/token");
+            const sign = await this.computeSign("POST", "/v4/token");
             const headers = this.getHeaders(sign);
 
-            const response = await axios.post(
+            const response = await fetch(
                 "https://api.extscreen.com/aliyundrive/v4/token",
-                reqBody,
-                { headers, timeout: 10000 }
+                {
+                    method: "POST",
+                    headers: headers,
+                    body: JSON.stringify(reqBody)
+                }
             );
 
             console.log("[*] (Sign) Response Status:", response.status);
-            console.log("[*] (Sign) Response Body:", response.data);
+            const responseData = await response.json() as ApiResponse;
+            console.log("[*] (Sign) Response Body:", responseData);
+
+            // 类型安全检查
+            if (!responseData) {
+                throw new Error("Invalid response data");
+            }
+
+            // 检查响应数据中是否有code字段
+            if (responseData.code !== undefined && responseData.code !== 200) {
+                throw new Error(JSON.stringify(responseData));
+            }
 
-            if (response.data?.code !== 200) {
-                throw new Error(JSON.stringify(response.data));
+            // 类型安全地访问data字段
+            if (!responseData.data) {
+                throw new Error("Response missing data field");
             }
 
-            const tokenData = response.data.data;
-            const t = response.data.t || this.timestamp;
-            return this.decrypt(tokenData.ciphertext, tokenData.iv, t);
+            const tokenData = responseData.data as TokenData;
+            const t = responseData.t ? responseData.t.toString() : this.timestamp;
+
+            if (!tokenData.ciphertext || !tokenData.iv) {
+                throw new Error("Token data missing required fields");
+            }
+
+            return await this.decrypt(tokenData.ciphertext, tokenData.iv, t);
         } catch (error) {
             console.error("获取Token错误:", error);
             throw error;
@@ -245,9 +362,12 @@
     }
 
     public async getRefreshtoken(authToken: string): Promise<string> {
+        // 确保已初始化
+        await this.ensureInitialized();
+
         try {
             const bodyObj = { code: authToken };
-            const encrypted = this.encrypt(bodyObj);
+            const encrypted = await this.encrypt(bodyObj);
             const reqBody = {
                 iv: encrypted.iv,
                 ciphertext: encrypted.ciphertext
@@ -255,27 +375,47 @@
 
             console.log("[*] (Sign) Request Body:", JSON.stringify(reqBody));
 
-            const sign = this.computeSign("POST", "/v4/token");
+            const sign = await this.computeSign("POST", "/v4/token");
             const headers = this.getHeaders(sign);
 
             console.log("[*] (Sign) Headers:", headers);
 
-            const response = await axios.post(
+            const response = await fetch(
                 "https://api.extscreen.com/aliyundrive/v4/token",
-                reqBody,
-                { headers, timeout: 10000 }
+                {
+                    method: "POST",
+                    headers: headers,
+                    body: JSON.stringify(reqBody)
+                }
             );
 
             console.log("[*] (Sign) Response Status:", response.status);
-            console.log("[*] (Sign) Response Body:", response.data);
+            const responseData = await response.json() as ApiResponse;
+            console.log("[*] (Sign) Response Body:", responseData);
+
+            // 类型安全检查
+            if (!responseData) {
+                throw new Error("Invalid response data");
+            }
+
+            // 检查响应数据中是否有code字段
+            if (responseData.code !== undefined && responseData.code !== 200) {
+                throw new Error(JSON.stringify(responseData));
+            }
 
-            if (response.data?.code !== 200) {
-                throw new Error(JSON.stringify(response.data));
+            // 类型安全地访问data字段
+            if (!responseData.data) {
+                throw new Error("Response missing data field");
             }
 
-            const tokenData = response.data.data;
-            const t = response.data.t || this.timestamp;
-            return this.decrypt(tokenData.ciphertext, tokenData.iv, t);
+            const tokenData = responseData.data as TokenData;
+            const t = responseData.t ? responseData.t.toString() : this.timestamp;
+
+            if (!tokenData.ciphertext || !tokenData.iv) {
+                throw new Error("Token data missing required fields");
+            }
+
+            return await this.decrypt(tokenData.ciphertext, tokenData.iv, t);
         } catch (error) {
             console.error("获取RefreshToken错误:", error);
             throw error;
@@ -283,14 +423,18 @@
     }
 
     public async getQrcodeUrl(): Promise<{ qr_link: string, sid: string }> {
+        // 确保已初始化
+        await this.ensureInitialized();
+
         try {
+            // 使用与Python代码完全一致的参数结构
             const bodyObj = {
-                scopes: "user:base,file:all:read,file:all:write",
+                scopes: ["user:base", "file:all:read", "file:all:write"].join(","),
                 width: 500,
                 height: 500
             };
 
-            const encrypted = this.encrypt(bodyObj);
+            const encrypted = await this.encrypt(bodyObj);
             const reqBody = {
                 iv: encrypted.iv,
                 ciphertext: encrypted.ciphertext
@@ -298,28 +442,52 @@
 
             console.log("[*] (Qrcode) Request Body:", JSON.stringify(reqBody));
 
-            const sign = this.computeSign("POST", "/v2/qrcode");
+            const sign = await this.computeSign("POST", "/v2/qrcode");
             const headers = this.getHeaders(sign);
 
-            const response = await axios.post(
+            const response = await fetch(
                 "https://api.extscreen.com/aliyundrive/v2/qrcode",
-                reqBody,
-                { headers, timeout: 10000 }
+                {
+                    method: "POST",
+                    headers: headers,
+                    body: JSON.stringify(reqBody)
+                }
             );
 
             console.log("[*] (Qrcode) Response Status:", response.status);
-            console.log("[*] (Qrcode) Response Body:", response.data);
+            const responseData = await response.json() as ApiResponse;
+            console.log("[*] (Qrcode) Response Body:", responseData);
+
+            // 类型安全检查
+            if (!responseData) {
+                throw new Error("Invalid response data");
+            }
+
+            // 检查响应数据中是否有code字段
+            if (responseData.code !== undefined && responseData.code !== 200) {
+                throw new Error(JSON.stringify(responseData));
+            }
 
-            if (response.data?.code !== 200) {
-                throw new Error(JSON.stringify(response.data));
+            // 类型安全地访问data字段
+            if (!responseData.data) {
+                throw new Error("Response missing data field");
             }
 
-            const qrcodeData = response.data.data;
-            const t = response.data.t || this.timestamp;
-            const decryptedData = this.decrypt(qrcodeData.ciphertext, qrcodeData.iv, t);
-            const data = JSON.parse(decryptedData);
+            const qrcodeData = responseData.data as TokenData;
+            const t = responseData.t ? responseData.t.toString() : this.timestamp;
+
+            if (!qrcodeData.ciphertext || !qrcodeData.iv) {
+                throw new Error("QR code data missing required fields");
+            }
+
+            const decryptedData = await this.decrypt(qrcodeData.ciphertext, qrcodeData.iv, t);
+            const data = JSON.parse(decryptedData) as { sid?: string };
             console.log("[*] (Qrcode) Decrypted Data:", data);
 
+            if (!data.sid) {
+                throw new Error("Missing sid in decrypted data");
+            }
+
             const qrLink = "https://www.aliyundrive.com/o/oauth/authorize?sid=" + data.sid;
             return { qr_link: qrLink, sid: data.sid };
         } catch (error) {
@@ -329,95 +497,99 @@
     }
 }
 
-async function checkQrcodeStatus(sid: string): Promise<{ auth_code: string }> {
-    try {
-        let status = "NotLoggedIn";
-        let authCode: string | null = null;
-
-        while (status !== "LoginSuccess") {
-            await new Promise(resolve => setTimeout(resolve, 3000));
-            const response = await axios.get(
-                `https://openapi.alipan.com/oauth/qrcode/${sid}/status`,
-                { timeout: 10000 }
-            );
-
-            status = response.data.status;
-            if (status === "LoginSuccess") {
-                authCode = response.data.authCode;
-            }
-        }
-
-        return { auth_code: authCode! };
-    } catch (error) {
-        console.error("检查二维码状态错误:", error);
-        throw error;
-    }
-}
+// 延迟创建实例 - 不在全局作用域中执行
+let clientInstance: AliyunPanTvToken | null = null;
 
-// Express 路由
-app.get("/", (req: Request, res: Response) => {
-    res.send(`
-        <html>
-            <body>
-                <h1>阿里云盘TV版认证服务</h1>
-                <div id="qrcode"></div>
-                <script>
-                    // 这里可以添加前端逻辑来显示二维码
-                </script>
-            </body>
-        </html>
-    `);
-});
+// 获取客户端实例的函数
+function getClient(): AliyunPanTvToken {
+    if (!clientInstance) {
+        clientInstance = new AliyunPanTvToken();
+    }
+    return clientInstance;
+}
 
-app.get("/get_qrcode", async (req: Request, res: Response) => {
+
+// 导出的接口函数保持不变
+export async function getQRCode(c: Context) {
     try {
+        const client = getClient();
         const qrData = await client.getQrcodeUrl();
-        res.json(qrData);
+        return c.json({ text: qrData.qr_link, sid: qrData.sid });
     } catch (error) {
-        res.status(500).json({ error: "获取二维码失败" });
+        console.error("获取二维码失败:", error);
+        return c.json({ text: "获取二维码失败" }, 500);
     }
-});
+}
 
-app.get("/check_qrcode/:sid", async (req: Request, res: Response) => {
+export async function checkStatus(c: Context) {
     try {
-        const sid = req.params.sid;
+        const sid = c.req.query('sid');
+        if (!sid) {
+            return c.json({ text: "缺少sid参数" }, 400);
+        }
+
         const status = await checkQrcodeStatus(sid);
-        res.json(status);
+        if (status) {
+            return c.json(status);
+        }
+
+        return c.json({ text: "等待扫码" }, 202);
     } catch (error) {
-        res.status(500).json({ error: "检查二维码状态失败" });
+        console.error("检查状态失败:", error);
+        return c.json({ text: "检查状态失败" }, 500);
     }
-});
+}
 
-app.post("/oauth/alipan/authtoken", async (req: Request, res: Response) => {
+async function checkQrcodeStatus(sid: string): Promise<{ auth_code: string } | null> {
     try {
-        const authCode = req.body.auth_code;
+        const response = await fetch(
+            `https://openapi.alipan.com/oauth/qrcode/${sid}/status`
+        );
+
+        if (!response.ok) {
+            return null;
+        }
+
+        const data = await response.json() as { status?: string; authCode?: string };
+        if (data && data.status === "LoginSuccess" && data.authCode) {
+            return { auth_code: data.authCode };
+        }
+
+        return null;
+    } catch (error) {
+        console.error("检查二维码状态错误:", error);
+        throw error;
+    }
+}
+
+export async function getTokenByAuthCode(c: Context) {
+    try {
+        const authCode = c.req.query('auth_code');
         if (!authCode) {
-            return res.status(400).json({ error: "缺少auth_code" });
+            return c.json({ text: "缺少auth_code参数" }, 400);
         }
 
-        const token = await client.getRefreshtoken(authCode);
-        console.log("[*] (AliYunPanTV) Token:", token);
-        res.status(200).send(token);
+        const client = getClient();
+        const tokenData = await client.getRefreshtoken(authCode);
+        return c.json(JSON.parse(tokenData));
     } catch (error) {
-        res.status(500).json({ error: "获取Token失败" });
+        console.error("获取Token失败:", error);
+        return c.json({ text: "获取Token失败" }, 500);
     }
-});
+}
 
-app.post('/oauth/alipan/token', async (req: Request, res: Response) => {
+export async function refreshToken(c: Context) {
     try {
-        const refreshToken = req.body.refresh_token;
+        const refreshToken = c.req.query('refresh_ui');
         if (!refreshToken) {
-            return res.status(400).json({ error: "缺少refresh_token" });
+            return c.json({ text: "缺少refresh_token参数" }, 400);
         }
 
-        const token = await client.getToken(refreshToken);
-        res.status(200).send(token);
+        const client = getClient();
+        const tokenData = await client.getToken(refreshToken);
+        return c.json(JSON.parse(tokenData));
     } catch (error) {
-        res.status(500).json({ error: "刷新Token失败" });
+        console.error("刷新Token失败:", error);
+        return c.json({ text: "刷新Token失败" }, 500);
     }
-});
-
-
-
-const client = new AliyunPanTvToken();
-
+}
\ No newline at end of file
Index: public/static/aliv2.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/static/aliv2.js b/public/static/aliv2.js
--- a/public/static/aliv2.js	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/public/static/aliv2.js	(date 1751453847209)
@@ -1,249 +1,194 @@
-// 生成客户端指纹
-function generateClientFingerprint() {
-    if (clientFingerprint) return clientFingerprint;
-
-    const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
-    ctx.textBaseline = 'top';
-    ctx.font = '14px Arial';
-    ctx.fillText('Client fingerprint', 2, 2);
-
-    const fingerprint = [
-        navigator.userAgent,
-        navigator.language,
-        screen.width + 'x' + screen.height,
-        new Date().getTimezoneOffset(),
-        canvas.toDataURL(),
-        navigator.hardwareConcurrency || 'unknown',
-        navigator.deviceMemory || 'unknown'
-    ].join('|');
-
-    // 生成简单的哈希
-    let hash = 0;
-    for (let i = 0; i < fingerprint.length; i++) {
-        const char = fingerprint.charCodeAt(i);
-        hash = ((hash << 5) - hash) + char;
-        hash = hash & hash; // 转换为32位整数
-    }
-
-    clientFingerprint = Math.abs(hash).toString(36);
-    // console.log('客户端指纹生成:', clientFingerprint);
-    return clientFingerprint;
-}
-
-// 发送带有客户端指纹的请求
-async function fetchWithFingerprint(url, options = {}) {
-    const fingerprint = generateClientFingerprint();
-    const headers = {
-        'X-Client-Fingerprint': fingerprint,
-        ...options.headers
-    };
-
-    return fetch(url, {
-        ...options,
-        headers
-    });
-}
+// 阿里云盘扫码登录v2
+class AlicloudQRLogin {
+    constructor() {
+        // 创建QR登录管理器实例
+        this.qrManager = new QRLoginManager({
+            onSuccess: this.handleLoginSuccess.bind(this)
+        });
+    }
 
-// 启动阿里云盘扫码v2登录
-async function startAlicloud2Login() {
-    try {
-        // 显示模态框
-        document.getElementById('qr-modal').style.display = 'block';
-        setQRStatus('正在生成二维码...', 'waiting');
+    // 启动阿里云盘扫码v2登录
+    async startLogin() {
+        try {
+            // 显示模态框
+            this.qrManager.showModal('阿里云盘扫码登录v2');
 
-        // 生成二维码 - 使用带指纹的请求
-        const response = await fetchWithFingerprint('/alicloud2/generate_qr');
-        const result = await response.json();
+            // 生成二维码
+            const response = await this.qrManager.fetchWithFingerprint('/alicloud2/generate_qr');
+            const result = await response.json();
 
-        if (result.success) {
-            alicloud2SessionId = result.session_id;
-            alicloud2StartTime = Date.now();
-            showQRCode(result.qr_code_url);
-            setQRStatus('请使用阿里云盘App扫描二维码', 'waiting');
+            if (result.success) {
+                this.qrManager.sessionId = result.session_id;
+                this.qrManager.provider = 'alicloud';
+                this.qrManager.showQRCode(result.qr_code_url);
+                this.qrManager.setStatus('请使用阿里云盘App扫描二维码', 'waiting');
 
-            // 显示过期时间信息
-            if (result.expires_in) {
-                const expireMinutes = Math.floor(result.expires_in / 60);
-                // console.log(`会话将在 ${expireMinutes} 分钟后过期`);
-            }
-
-            startStatusCheck();
-        } else {
-            setQRStatus(result.error || '生成二维码失败', 'error');
-            document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-        }
-    } catch (error) {
-        setQRStatus('网络错误，请重试', 'error');
-        document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-        console.error('生成二维码失败:', error);
-    }
-}
-
-// 显示二维码
-function showQRCode(qrUrl) {
-    const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrUrl)}`;
-    document.getElementById('qr-code-display').innerHTML = `<img src="${qrApiUrl}" alt="二维码" class="qr-code-img">`;
-    document.getElementById('qr-code-container').style.display = 'block';
-}
-
-// 设置状态
-function setQRStatus(message, type) {
-    const statusEl = document.getElementById('qr-status');
-    statusEl.textContent = message;
-    statusEl.className = `qr-status ${type}`;
-    statusEl.style.display = 'block';
-}
-
-// 开始状态检查
-function startStatusCheck() {
-    stopStatusCheck();
-    alicloud2CheckInterval = setInterval(checkAlicloud2Status, 2000);
-}
-
-// 停止状态检查
-function stopStatusCheck() {
-    if (alicloud2CheckInterval) {
-        clearInterval(alicloud2CheckInterval);
-        alicloud2CheckInterval = null;
+                // 开始检查状态
+                this.qrManager.startStatusCheck(this.checkStatus.bind(this));
+            } else {
+                this.qrManager.setStatus(result.error || '生成二维码失败', 'error');
+                document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+            }
+        } catch (error) {
+            console.error('生成二维码失败:', error);
+            this.qrManager.setStatus('网络错误，请重试', 'error');
+            document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+        }
     }
-}
 
-// 检查登录状态
-async function checkAlicloud2Status() {
-    if (!alicloud2SessionId) return;
-
-    // 检查是否超过3分钟（二维码可能过期）
-    const elapsed = Date.now() - alicloud2StartTime;
-    if (elapsed > 180000) { // 3分钟
-        setQRStatus('二维码可能已过期，建议点击刷新重新生成', 'error');
-        document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-        stopStatusCheck();
-        return;
-    }
+    // 检查登录状态
+    async checkStatus(elapsed) {
+        if (!this.qrManager.sessionId) return;
 
-    try {
-        // 使用带指纹的请求
-        const response = await fetchWithFingerprint(`/alicloud2/check_login?session_id=${alicloud2SessionId}`);
-        const result = await response.json();
+        try {
+            const response = await this.qrManager.fetchWithFingerprint(
+                `/alicloud2/check_login?session_id=${this.qrManager.sessionId}`
+            );
+            const result = await response.json();
 
-        if (result.success) {
-            switch (result.status) {
-                case 'WAITING':
-                    const waitTime = Math.floor(elapsed / 1000);
-                    setQRStatus(`等待扫描... (${waitTime}s) 请使用阿里云盘App扫码`, 'waiting');
-                    break;
-                case 'SCANED':
-                    setQRStatus('已扫描，请在手机上确认登录', 'scaned');
-                    break;
-                case 'CONFIRMED':
-                    setQRStatus('登录成功！正在获取用户信息...', 'success');
-                    stopStatusCheck();
-                    // 稍等一下确保token已保存
-                    setTimeout(async () => {
-                        await getAlicloud2UserInfo();
-                    }, 1000);
-                    break;
-                case 'EXPIRED':
-                    setQRStatus('二维码已过期，请点击刷新重新生成', 'error');
-                    stopStatusCheck();
-                    document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-                    break;
-            }
-        } else {
-            // 处理会话验证失败的情况
-            if (response.status === 403) {
-                setQRStatus('会话验证失败，请重新生成二维码', 'error');
-                document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-                stopStatusCheck();
-            } else {
-                setQRStatus('检查状态失败: ' + (result.error || '未知错误'), 'error');
-                document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-            }
-        }
-    } catch (error) {
-        console.error('检查登录状态失败:', error);
-        setQRStatus('网络连接失败，请检查网络后重试', 'error');
-        document.getElementById('refresh-qr-btn').style.display = 'inline-block';
-    }
-}
+            if (result.success) {
+                switch (result.status) {
+                    case 'WAITING':
+                        const waitTime = Math.floor(elapsed / 1000);
+                        this.qrManager.setStatus(`等待扫描... (${waitTime}s) 请使用阿里云盘App扫码`, 'waiting');
+                        break;
+                    case 'SCANED':
+                        this.qrManager.setStatus('已扫描，请在手机上确认登录', 'scaned');
+                        break;
+                    case 'CONFIRMED':
+                        this.qrManager.setStatus('登录成功！正在获取用户信息...', 'success');
+                        this.qrManager.stopStatusCheck();
+                        setTimeout(async () => {
+                            await this.getUserInfo();
+                        }, 1000);
+                        break;
+                    case 'EXPIRED':
+                        this.qrManager.setStatus('二维码已过期，请点击刷新重新生成', 'error');
+                        this.qrManager.stopStatusCheck();
+                        document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+                        break;
+                }
+            } else {
+                if (response.status === 403) {
+                    this.qrManager.setStatus('会话验证失败，请重新生成二维码', 'error');
+                    this.qrManager.stopStatusCheck();
+                    document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+                } else {
+                    this.qrManager.setStatus('检查状态失败: ' + (result.error || '未知错误'), 'error');
+                    document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+                }
+            }
+        } catch (error) {
+            console.error('检查登录状态失败:', error);
+            this.qrManager.setStatus('网络连接失败，请检查网络后重试', 'error');
+            document.getElementById(this.qrManager.refreshBtnId).style.display = 'inline-block';
+        }
+    }
 
-// 获取用户信息
-async function getAlicloud2UserInfo() {
-    if (!alicloud2SessionId) return;
+    // 获取用户信息
+    async getUserInfo() {
+        if (!this.qrManager.sessionId) return;
 
-    try {
-        // 使用带指纹的请求
-        const response = await fetchWithFingerprint(`/alicloud2/get_user_info?session_id=${alicloud2SessionId}`);
-        const result = await response.json();
+        try {
+            const response = await this.qrManager.fetchWithFingerprint(
+                `/alicloud2/get_user_info?session_id=${this.qrManager.sessionId}`
+            );
+            const result = await response.json();
 
-        if (result.success && result.user_info) {
-            // 关闭模态框
-            closeQRModal();
+            if (result.success && result.user_info) {
+                // 关闭模态框
+                this.qrManager.closeModal();
 
-            // 显示成功消息
-            await Swal.fire({
-                position: 'top',
-                icon: 'success',
-                title: '登录成功',
-                html: `<div>用户: ${result.user_info.nick_name || result.user_info.user_id}</div>`,
-                showConfirmButton: true
-            });
+                // 显示成功消息
+                await Swal.fire({
+                    position: 'top',
+                    icon: 'success',
+                    title: '登录成功',
+                    html: `<div>用户: ${result.user_info.nick_name || result.user_info.user_id}</div>`,
+                    showConfirmButton: true
+                });
 
-            // 填充token字段（使用真实的tokens）
-            if (result.access_token) {
-                document.getElementById("access-token").value = result.access_token;
-            }
-            if (result.refresh_token) {
-                document.getElementById("refresh-token").value = result.refresh_token;
-            }
+                // 填充token字段
+                if (result.access_token) {
+                    document.getElementById("access-token").value = result.access_token;
+                }
+                if (result.refresh_token) {
+                    document.getElementById("refresh-token").value = result.refresh_token;
+                }
 
-            // 清理会话
-            await fetchWithFingerprint(`/alicloud2/logout?session_id=${alicloud2SessionId}`);
-            alicloud2SessionId = null;
-        } else {
-            // 处理会话验证失败的情况
-            if (response.status === 403) {
-                setQRStatus('会话验证失败，请重新登录', 'error');
-            } else {
-                setQRStatus('获取用户信息失败: ' + (result.error || '未知错误'), 'error');
-            }
-        }
-    } catch (error) {
-        setQRStatus('获取用户信息失败', 'error');
-        console.error('获取用户信息失败:', error);
-    }
-}
+                // 执行成功回调
+                this.qrManager.onSuccess(result);
+
+                // 清理会话
+                await this.qrManager.fetchWithFingerprint(`/alicloud2/logout?session_id=${this.qrManager.sessionId}`);
+                this.qrManager.sessionId = null;
+            } else {
+                if (response.status === 403) {
+                    this.qrManager.setStatus('会话验证失败，请重新登录', 'error');
+                } else {
+                    this.qrManager.setStatus('获取用户信息失败: ' + (result.error || '未知错误'), 'error');
+                }
+            }
+        } catch (error) {
+            this.qrManager.setStatus('获取用户信息失败', 'error');
+            console.error('获取用户信息失败:', error);
+        }
+    }
 
-// 刷新二维码
-async function refreshQRCode() {
-    document.getElementById('refresh-qr-btn').style.display = 'none';
-    // 清理旧会话
-    if (alicloud2SessionId) {
-        try {
-            await fetchWithFingerprint(`/alicloud2/logout?session_id=${alicloud2SessionId}`);
-        } catch (e) {
-            // console.log('清理旧会话失败:', e);
+    // 刷新二维码
+    async refreshQRCode() {
+        document.getElementById(this.qrManager.refreshBtnId).style.display = 'none';
+
+        // 清理旧会话
+        if (this.qrManager.sessionId) {
+            try {
+                await this.qrManager.fetchWithFingerprint(`/alicloud2/logout?session_id=${this.qrManager.sessionId}`);
+            } catch (e) {
+                console.error('清理旧会话失败:', e);
+            }
+            this.qrManager.sessionId = null;
         }
-        alicloud2SessionId = null;
+
+        await this.startLogin();
     }
-    await startAlicloud2Login();
+
+    // 登录成功处理函数
+    handleLoginSuccess(result) {
+        console.log('阿里云盘登录成功:', result);
+    }
 }
+
+// 创建全局实例
+window.alicloudQRLogin = new AlicloudQRLogin();
+
+// 开始登录
+function startAlicloud2Login() {
+    window.alicloudQRLogin.startLogin();
+}
+
+// 刷新二维码
+function refreshQRCode() {
+    window.alicloudQRLogin.refreshQRCode();
+}
 
 // 关闭模态框
+// 全局关闭模态框函数
 function closeQRModal() {
-    document.getElementById('qr-modal').style.display = 'none';
-    stopStatusCheck();
-
-    // 清理会话
-    if (alicloud2SessionId) {
-        fetchWithFingerprint(`/alicloud2/logout?session_id=${alicloud2SessionId}`);
-        alicloud2SessionId = null;
+    // 直接操作DOM关闭模态框，而不是调用实例方法
+    const modal = document.getElementById('qr-modal');
+    if (modal) {
+        modal.style.display = 'none';
     }
 
-    // 重置界面
-    document.getElementById('qr-code-container').style.display = 'none';
-    document.getElementById('qr-status').style.display = 'none';
-    document.getElementById('refresh-qr-btn').style.display = 'none';
-}
+    // 如果有活跃的检查间隔，清除它
+    if (window.alicloudQRLogin && window.alicloudQRLogin.qrManager) {
+        window.alicloudQRLogin.qrManager.stopStatusCheck();
+        window.alicloudQRLogin.qrManager.resetUI();
+    }
 
+    // 同样处理aliTV的情况
+    if (window.alitvQRLogin && window.alitvQRLogin.qrManager) {
+        window.alitvQRLogin.qrManager.stopStatusCheck();
+        window.alitvQRLogin.qrManager.resetUI();
+    }
+}
\ No newline at end of file
Index: public/static/login.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/static/login.js b/public/static/login.js
--- a/public/static/login.js	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/public/static/login.js	(date 1751442928953)
@@ -12,7 +12,7 @@
     let check_flag = true;
     // 验证秘钥情况 ==================================================
     if (!server_use) {
-        if (driver_txt !== "alicloud_cs" && driver_pre !== "baiduyun")
+        if (driver_txt !== "alicloud_cs" && driver_txt !== "alicloud_tv" && driver_pre !== "baiduyun")
             if (client_uid === "" || client_key === "")
                 check_flag = false
         if (driver_pre === "baiduyun")
@@ -24,11 +24,19 @@
             return;
         }
     }
+
     // 阿里云盘扫码v2直接调用专用API，不需要构建传统的requests路径
     if (driver_txt === "alicloud_cs" && !refresh) {
         await startAlicloud2Login();
         return;
     }
+
+    // 阿里云盘TV版扫码登录，使用新的专用函数
+    if (driver_txt === "alicloud_tv" && !refresh) {
+        await startAliTVLogin();
+        return;
+    }
+
     // 刷新秘钥情况 =================================================
     let base_urls = "/requests?client_uid="
     if (refresh) {
@@ -109,8 +117,8 @@
                 document.getElementById("access-token").value = response_data.text;
                 return;
             }
-            // Ali网盘直接获取 ===========================================================
-            if (driver_txt === "alicloud_qr" || driver_txt === "alicloud_tv") {
+            // Ali网盘原有扫码方式 ===========================================================
+            if (driver_txt === "alicloud_qr") {
                 let sid = response_data.sid;
                 await Swal.fire({
                     position: 'top',
@@ -152,4 +160,4 @@
 
 function encodeCallbackData(data) {
     return btoa(JSON.stringify(data))
-}
+}
\ No newline at end of file
Index: src/index.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/index.ts b/src/index.ts
--- a/src/index.ts	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/src/index.ts	(date 1751444252381)
@@ -9,6 +9,7 @@
 import * as yanui from './driver/yandexui_oa';
 import * as drops from './driver/dropboxs_oa';
 import * as quark from './driver/quarkpan_oa';
+import * as alitv from './driver/alicloud_tv';
 
 export type Bindings = {
     MAIN_URLS: string, baiduyun_ext: string,
@@ -173,5 +174,24 @@
     return await quark.apiRenew(c);
 });
 
+// 阿里云盘TV版 - 获取二维码 ##############################################################################
+app.get('/alitv/qrcode', async (c: Context) => {
+    return await alitv.getQRCode(c);
+});
+
+// 阿里云盘TV版 - 检查扫码状态 ##############################################################################
+app.get('/alitv/check', async (c: Context) => {
+    return await alitv.checkStatus(c);
+});
+
+// 阿里云盘TV版 - 获取Token ##############################################################################
+app.get('/alitv/token', async (c: Context) => {
+    return await alitv.getTokenByAuthCode(c);
+});
+
+// 阿里云盘TV版 - 刷新Token ##############################################################################
+app.get('/alitv/renewapi', async (c: Context) => {
+    return await alitv.refreshToken(c);
+});
 
 export default app
Index: public/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/index.html b/public/index.html
--- a/public/index.html	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/public/index.html	(date 1751442954312)
@@ -147,10 +147,12 @@
 </div>
 
 <script src="/static/event.js"></script>
+<script src="/static/qrlogin.js"></script>
 <script src="/static/login.js"></script>
 <script src="/static/token.js"></script>
 <script src="/static/theme.js"></script>
 <script src="/static/aliv2.js"></script>
+<script src="/static/alitv.js"></script>
 <script src="/static/eulas.js"></script>
 <script src="/static/spoid.js"></script>
 <script src="/static/input.js"></script>
Index: public/static/event.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/public/static/event.js b/public/static/event.js
--- a/public/static/event.js	(revision 0568e1e9fc73381c591f354547c025148fdd751a)
+++ b/public/static/event.js	(date 1751372689745)
@@ -32,7 +32,7 @@
     const serverUseContainer = server_use_input.closest('.mb-3');
     const callbackContainer = direct_url_input.closest('.mb-3');
     // 阿里云盘扫码登录v2不需要客户端ID、应用机密和回调地址 ================
-    if (driver_txt_input.value === "alicloud_cs") {
+    if (driver_txt_input.value === "alicloud_cs" || driver_txt_input.value === "alicloud_tv") {
         // 隐藏整个字段容器
         clientIdContainer.style.display = 'none';
         appSecretContainer.style.display = 'none';
@@ -78,7 +78,8 @@
         driver_txt_input.value === "onedrive_us" ||
         driver_txt_input.value === "onedrive_de" ||
         driver_txt_input.value === "alicloud_cs" ||
-        driver_txt_input.value === "dropboxs_go"
+        driver_txt_input.value === "dropboxs_go" ||
+        driver_txt_input.value === "alicloud_tv"
     ) {
         server_use_input.checked = false;
         server_use_input.disabled = true;
